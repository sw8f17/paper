\section{Implementing Synchronization}\label{sec:impl_sync}
In this section we discuss how we implement the methods of synchronization we discussed in \cref{cha:sync}.
First we summarize what lead us to implementing synchronization the way we did.
Then we will explain how each of the implemented synchronization methods work, and lastly we explain where we use the synchronization in the app.

In it we decided, in \cref{sec:sync_conclusion}, that NTP would suit us best.
However for practical reason we decided to implement \ac{SNTP}, which as the name suggests is a simplified version of \ac{NTP}, but does not require storing the state over time.
This solution requires each device to synchronize with an \ac{NTP}-server over the internet.

Since a persistent internet connection is not an ideal requirement for our application we also implemented our own time-synchronization over the local network, we create using WiFi Direct.
This method would not synchronize each client to a global clock, like \ac{NTP} and \ac{SNTP} does, but rather synchronize the clock of the clients to the clock of the server.
However for our application this it not a worry, our goal is to synchronize audio accurately across devices in our network, which does not require each clock to be globally synchronized, only locally.

We decided to implement both of these, that is \ac{SNTP} over the internet and time-synchronization over the WiFi Direct.
Then we will benchmark them to determine the solution which requires internet is better, and thusly justify the added requirement for the users.

As a side note, it is not possible for non-rooted Android devices to change the clock of the device, except with manual input in the setting menu.
For this reason we will not synchronize our clocks on the devices, but rather find the offset between the clock on a given device, and the clock of the \ac{NTP}-server or master.

\subsection{\ac{SNTP} over the Internet}
In this method, the goal is to get the offset of every device in the network, clients and server, relative to a 3rd party \ac{NTP}-server.
\ac{NTP} and \ac{SNTP} works by sending timestamped packages from the client to the server, and back.
This is illustrated in \cref{fig:ntp_packets}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}[auto]
        \draw[->] (0, 0) -- (4.5, 0);
        \draw[->] (0,-2) -- (4.5,-2);

        \draw (0.5, -2) -- (2, 0);
        \draw (4.0, -2) -- (2.5, 0);

        \draw (2.25, -3) node {$Time$} node[above=3pt] {$   $};

        \draw (0,  0) node[left=3pt] {$NTP-server$};
        \draw (0, -2) node[left=3pt] {$Client$};

        \draw (0.5, -2) node[below=3pt] {$T_0$};
        \draw (4.0, -2) node[below=3pt] {$T_3$};
        \draw (2  ,  0) node[above=3pt] {$T_1$};
        \draw (2.5,  0) node[above=3pt] {$T_2$};
    \end{tikzpicture}
    \caption{The timestamps sent and received during \ac{NTP} synchronization.}
    \label{fig:ntp_packets}
\end{figure}

Here $T_0$ is the timestamp, on the client, where the request was sent, $T_1$ is the timestamp, on the server, when the request was received.
$T_2$ is the timestamp, on the server, when the response was sent, and $T_3$, is the timestamp, on the client, when the response was received.
Given this one can calculate the offset, $\theta$, with the equation \ref{eq:ntp}.

\begin{equation}\label{eq:ntp}
    \theta = \frac{(t_1 - t_0)+(t_2 - t_3)}{2}
\end{equation}

\ac{SNTP} only considers one of these offsets: the latest, where \ac{NTP} uses multiple and discards outliers.
When using \ac{NTP} one also have to decide on what \ac{NTP}-server to use.
We decided to use \url{0.dk.pool.ntp.org} which is an \ac{NTP}-pool, which is free to use, and its servers are located in Denmark, and we get a very low latency to them, which can improve accuracy.

\subsection{Time-synchronization over WiFi Direct}
As we explained in the start of this section, we would consider it advantageous not to require our users to be connected to the internet.
Implementing time-synchronization over WiFi Direct, independently of any 3rd party server on this internet would remove this requirement.

Our way of time-synchronization over WiFi Direct, uses the same methods as the method we just explained about \ac{SNTP} over the internet, with the change that the master of the network would also act as an \ac{NTP}-server.

Implementing this requires us to add two protobufs, one for the request, and one for the response.
The request contains a single timestamp: The timestamp of the client when it sent the request.
The response contains three timestamps: It sends the initial timestamp which it received from the client, the timestamp for when it received it, and the timestamp for when it sends the response.
From this the client can note the timestamp when it receives the response, and thus it has all four timestamps, and can calculate its clock offset, $\theta$, relative to the master clock.

Implementing this on the server side is really simple, since it now is the master clock, the offset of it to the master clock is by definition zero.
Additionally it has to receive the requests and respond to them.
This is done by registering a callback which will be called whenever a request comes in, then record the two timestamps, build the response, and send it back.

The client side has to send the requests periodically, in order to avoid clock drift.
And like the server, it has to register a callback for when responses arrive, from which is can calculate the offset and save it.
Any part of the system which needs the offset can then ask for it, and will receive the latest recorded offset.

\subsection{Using the Synchronization in the App}
Now that we have offsets, and can therefore convert local timestamps to be synchronized with the rest of the network.
For simplicity we decided to use the offset our synchronization gave us just before sending messages over the network, and just after receiving them.
That is, when we send a message, the timestamp in it is of the master clock, and when we receive a message, it is converted to the local clock.
This is illustrated in \ref{fig:sntp_example}.
Given this setup, the offsets are $-1s925ms$ for the server relative to the \ac{NTP}-server, and $-0s937.5ms$ for the client relative to the \ac{NTP}-server.

Say for example that we want to start playback in one second, $02s175ms$ (\ac{NTP} time), then the server would give that as the timestamp for the PlayCommand.
When the slave receives the message it will then translate the timestamp to its local time, by subtracting its offset:
$-0s937.5ms$ from the timestamp $02s175ms$: $02s175ms - (-0s937.5ms) = 3s112.5ms$.
That means that the client should start the playback at $3s112.5ms$ on its own clock.
The server should start its playback at $02s175ms - (-1s925ms) = 4s100ms.$

\begin{figure}[bth]
    \centering
    \begin{tikzpicture}[auto, line cap=rect,line width=1pt]
        % Baggrund
        \filldraw [fill=GoogleLightBlue] (0,0) circle [radius=1cm];
        % Tick hver 3. time
        \foreach \angle in {0,90,180,270}
          \draw[line width=2pt] (0,0) -- ++(\angle:0.975cm);

        \foreach \angle in {0,90,180,270}
          \draw[line width=3pt, color=GoogleLightBlue] (0,0) -- ++(\angle:0.80cm);
        % Time viser
        %\draw[line width=1.8pt] (0,0) -- ++(150:0.5cm);
        % Minut viser
        \draw[line width=1.2pt] (0,0) -- ++(70:0.7cm);


        % Baggrund
        \filldraw [fill=GoogleAmber] (3,0) circle [radius=1cm];
        % Tick hver 3. time
        \foreach \angle in {0,90,180,270}
          \draw[line width=2pt] (3,0) -- ++(\angle:0.975cm);

        \foreach \angle in {0,90,180,270}
          \draw[line width=3pt, color=GoogleAmber] (3,0) -- ++(\angle:0.80cm);
        % Time viser
        %\draw[line width=1.8pt] (3,0) -- ++(150:0.5cm);
        % Minut viser
        \draw[line width=1.2pt] (3,0) -- ++(85:0.7cm);


        % Baggrund
        \filldraw [fill=GoogleLightGreen] (6,0) circle [radius=1cm];
        % Tick hver 3. time
        \foreach \angle in {0,90,180,270}
          \draw[line width=2pt] (6,0) -- ++(\angle:0.975cm);

        \foreach \angle in {0,90,180,270}
          \draw[line width=3pt, color=GoogleLightGreen] (6,0) -- ++(\angle:0.80cm);
        % Time viser
        %\draw[line width=1.8pt] (6,0) -- ++(150:0.5cm);
        % Minut viser
        \draw[line width=1.2pt] (6,0) -- ++(80:0.7cm);

        \node[draw, thick, fill=GoogleLightBlue]    at (0,-1.6) {Master};
        \node[]                                     at (0,-2.2) {$03s050ms$};
        \node[draw, thick, fill=GoogleAmber]        at (3,-1.6) {NTP-server};
        \node[]                                     at (3,-2.2) {$01s175ms$};
        \node[draw, thick, fill=GoogleLightGreen]   at (6,-1.6) {Slave};
        \node[]                                     at (6,-2.2) {$02s250ms$};
    \end{tikzpicture}
    \caption{Example of \ac{SNTP} over the internet in action, only the second hand is shown.}
    \label{fig:sntp_example}
\end{figure}

This approach has some advantages and disadvantages, the biggest advantage is simplicity, it allows us to only think about time synchronization in one place, and not in the player itself.
However the disadvantage is that the longer we buffer data, the more outdated it gets.


% Hvor ofte skal vi synkronisere!?!

% eksempel p√• begge ?!?